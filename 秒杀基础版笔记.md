# 一、创建SpringBoot项目

## 1. 创建Maven项目

1. 选择maven项目
2. 选择maven archeType: xxxquck-start 作用是使用maven模板**创建项目目录模板**
3. 在main目录下创建resources目录 并设置为resource类型
4. 项目目录结构如图

<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gph9dguj4bj30dm0est9n.jpg" alt="image-20210412205938592" style="zoom:50%;" />

	5. 你对SpringBoot的认识？ SpringBoot集成了许多Spring框架 并使用默认配置开发项目 **约定大于配置** 标准化开发流程 提高开发效率

## 2. 引入SpringBoot依赖实现简单的web项目



1. 在Spring Guide页面打开Building a RESTful Web Service页面

2. 引入parent依赖

   ```xml
   <parent>
   		<groupId>org.springframework.boot</groupId>
   		<artifactId>spring-boot-starter-parent</artifactId>
   		<version>2.4.3</version>
   		<relativePath/> <!-- lookup parent from repository -->
   </parent>
   ```

3. 引入starter依赖

   ```xml
   <dependency>
   			<groupId>org.springframework.boot</groupId>
   			<artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   ```

4. ps: 也可以直接在创建项目时选择Spring Initializr自动导入依赖 省去1 2步

   <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gphd47dgw2j30ei0ew759.jpg" alt="image-20210412211949167" style="zoom:50%;" />

   

   Step1-Step4解释：

5. 在class App上添加自动配置注解**@EnableAutoConfiguration**: **将App类设置成SpringBoot自动化Bean** 实现**App项目依赖的自动加载管理**

6. 添加一行代码启动SpringBoot项目: SpringApplication.run(App.class, args); 此时8080 tomcat服务器启动 

7. 在class App上添加**@RestControlle**r注解：使用MVC模式中的C控制器 控制浏览器发出的http请求

8. 定义一个home()方法并添加**@RequestMapping("/")**注解：当浏览器请求url为/的资源时返回一个字符串

## 3. 集成MyBatis操作数据库

1. 在pom.xml修改默认tomcat 8080端口防止端口冲突：在resources目录下创建**appllication.properties**文件 配置端口 server.port=8090 十分方便

2. 在pom.xml添加myql 连接依赖

   ```xml
   <dependency>
     <groupId>mysql</groupId>
     <artifactId>mysql-connector-java</artifactId>
     <version>5.1.41</version>
   </dependency>
   ```

3. 在pom.xml添加druid连接池管理依赖

   ```xml
   <dependency>
     <groupId>com.alibaba</groupId>
     <artifactId>druid</artifactId>
     <version>1.1.3</version>
   </dependency>
   ```

4. 在pom.xml添加mybatis依赖

   ```xml
   <dependency>
     <groupId>org.mybatis.spring.boot</groupId>
     <artifactId>mybatis-spring-boot-starter</artifactId>
     <version>1.3.1</version>
   </dependency>
   ```

5. 在application.propertis配置mybatis映射目录：mybatis.mapperLocations=classpath:mapping/*.xml

6. 在resource目录下创建mapping目录

7. 在pom.xml添加mybatis自动生成数据库文件插件 

   ```xml
   <plugin>
     <groupId>org.mybatis.generator</groupId>
     <artifactId>mybatis-generator-maven-plugin</artifactId>
     <version>1.3.5</version>
   </plugin>
   ```

8. 添加mybatis插件需要core依赖 和mysql数据库解析依赖

   ```xml
   <dependencies>
     <dependency>
       <groupId>org.mybatis.generator</groupId>
       <artifactId>mybatis-generator-core</artifactId>
       <version>1.3.5</version>
     </dependency>
     <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>5.1.41</version>
     </dependency>
   </dependencies>
   ```

9. 配置mybatis执行环境

   ```xml
   <executions>
     <execution>
       <id>mybatis generator</id>
       <phase>package</phase>
       <goals>
         <goal>generate</goal>
       </goals>
     </execution>
   </executions>
   ```

10. 配置防止mybatis文件重复生成的属性

    ```xml
    <configuration>
      <!--允许移动生成的文件-->
      <verbose>true</verbose>
      <!--允许自动覆盖 生产环境禁止这样-->
      <overwrite>true</overwrite>
      <configurationFile>
        src/main/resources/mybatis-generator.xml
      </configurationFile>
    </configuration>
    ```

    

## 4. MyBatis自动生成器使用

1. 在resource目录下创建mybatis-generator.xml配置文件

2. 从mybatis官网下载mybatis-generator.xml配置文件复制到项目mybatis-generator.xml中

3. Navicat打开某个数据库连接 创建数据库 设置字符集

   <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gphd44y0n9j311m0b6aba.jpg" alt="image-20210412224527954" style="zoom:50%;" />

   

4. 创建用户表 设置id字段 int类型 不为null 主键 自动增长

5. 设置name字段 varchar类型 长度64B 不为null

6. 设置gender字段 tinyint类型 长度0 不为null  说明：1为男性 2为女性

7. 设置age int类型 不为null 默认值为0

8. 设置phone varchar类型 不为null 默认值为”“ 长度为0

9. 设置register-mode varchar 不为null 默认值”“ 长度为0 说明：三种注册模式byphone byweichat byalipay 做连登功能

10. 设置third_part_id varchar 64B 默认”“ 不为null 表示第三方登录id

11. 保存为user_info表

    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gphd45x1dhj31oa0gegpd.jpg" alt="image-20210412230513139" style="zoom:50%;" />

12. 注意密码没有包含 **密码为敏感信息** 包含在另一个系统中 **密码和主表分开存取**

13. 创建user_password表

14. 设置id encrpt_password密文加密方式 user_id字段作为外键关联user_info表

15. user_password表如图所示

    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gphfzbueecj31l60bwn00.jpg" alt="image-20210412231822234" style="zoom:50%;" />

16. 在mybatis-generator.xml配置mysql数据库连接url 数据库名 登录密码

    ```xml
    <jdbcConnection driverClass="com.mysql.jdbc.Driver"
                    connectionURL="jdbc:mysql://localhost:3306/seckill"
                    userId="root"
                    password="185530">
    </jdbcConnection>
    ```

17. 在项目目录中创建dataobject目录 在mybatis-generetor.xml配置数据库对象生成路径为dataobject目录路径

    ```xml
    <javaModelGenerator targetPackage="com.seckill.dataobject" 
                        targetProject="src/main/java">
      <property name="enableSubPackages" value="true" />
      <property name="trimStrings" value="true" />
    </javaModelGenerator>
    ```

18. 配置生成映射文件存放位置

    ```xml
    <sqlMapGenerator targetPackage="mapping"  targetProject="src/main/resources">
      <property name="enableSubPackages" value="true" />
    </sqlMapGenerator>
    ```

19. 配置生成Dao类存放位置 同时创建对应位置的dao目录

    ```xml
    <javaClientGenerator type="XMLMAPPER" targetPackage="com.seckill.dao"
                         targetProject="src/main/java">
      <property name="enableSubPackages" value="true" />
    </javaClientGenerator>
    ```

20. 生成对应表和类名

    ```xml
    <table tableName="user_info" domainObjectName="UserDO"></table>
    <table tableName="user_password" domainObjectName="UserPasswordDO"></table>
    ```

21. 配置mybatis-generator命令

    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gphfz9oibuj31ki0eg41q.jpg" alt="image-20210412234435755" style="zoom:50%;" />

22. 运行报错 Unable to load authentication plugin 'caching_sha2_password'. 修改pom.xml中mysql-connection-java版本即可 <version>8.0.11</version>

23. 运行后mybatis自动生成dao类和dataobject类模板文件

    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gphfzaeliaj30r20jigok.jpg" alt="image-20210413001358862" style="zoom:25%;" />

24. 配置mybatis-generator.xml去掉UserDOMappler.xml UserPasswordDOMapper.xml自动生成的复杂查询

    ```xml
    <table tableName="user_info" domainObjectName="UserDO"
           enableCountByExample="false" enableDeleteByExample="false"
           enableSelectByExample="false" enableUpdateByExample="false"
           selectByExampleQueryId="false"></table>
    <table tableName="user_password" domainObjectName="UserPasswordDO"
           enableCountByExample="false" enableDeleteByExample="false"
           enableSelectByExample="false" enableUpdateByExample="false"
           selectByExampleQueryId="false"></table>
    ```

25. 在application.properties中配置springboot datasource

    ```properties
    spring.datasource.name=seckill
    spring.datasource.url=jdbc:mysql://localhost:3306/seckill
    spring.datasource.username=root
    spring.datasource.password=185530
    ```

26. 在application.properties中配置springboot datasource具体实现类druid和数据库驱动

    ```properties
    spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
    spring.datasource.driverClassName=com.mysql.jdbc.Driver
    ```

27. 在App.java修改@EnableAutoConfiguration为@SpringBootApplication(scanBasePackages = {"com.seckill"}) 使springboot自动扫包目录下的组件 让其托管

28. 设置@MapperScan("com.seckill.dao")

29. 调试

    ```java
    @Autowired
    private UserDOMapper userDOMapper;
    
    @RequestMapping("/") // step 4
    public String home() {
      UserDO userDO = userDOMapper.selectByPrimaryKey(1);
      if (userDO == null) {
        return "用户对象不存在";
      } else {
        return userDO.getName();
      }
    }
    ```

30. 启动报错：Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. 取消手动配置

31. 启动报错：You need either to explicitly disable SSL by setting useSSL=false goole解决

32. 启动报错：java.sql.SQLSyntaxErrorException: Unknown column 'register' in 'field list 创建数据库是register_mode错写成register-mode

33. 重新启动mybatis-generator再启动App:

    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gphfzay9cyj30ik05sq3l.jpg" alt="image-20210413004758592" style="zoom:33%;" />

34. navicat插入一条数据 重启App 显示用户数据

    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpi4s1ovmmj30fy060mxe.jpg" alt="image-20210413094730784" style="zoom:25%;" />

    

# 二、用户模块开发

## . SpringMVC模式开发用户信息

1. 在seckill目录下创建controller目录 service目录 

2. 在controller目录编写UserController类 添加**@Controller("user")**标记用于spring扫描 user为SpringBoot自动生成的controller类

3. 在UserController类添加**@RequestMapping("/user")** 表示通过该路径访问此类

4. 编写getUser方法 接受@RequestParam(name="id")参数 函数功能是接受浏览器请求的id参数 调用service服务查询数据库返回该id对应的数据对象给前端

5. 给getUser指定访问路径**@RequestMapping("/get")**

6. 在service目录下创建**UserService接口和impl实现类目录

7. 在impl目录下创建UserServiceImpl类实现UserService接口

8. 在UserService接口中定义getUserById()接口

9. 在UserServiceImpl类中实现getUserById()接口：通过@AutoWired引入UserDOMappler对象 在通过userDOMapper对象查询返回UserDO对象

10. 在UserServiceImpl类上添加Spring Service标注**@Service**

11. SpringMVC分层模型：第一层DataObject(DO)与数据库对象一一映射 数据库有什么字段DO类就有什么字段 只有简单的getter setter方法

12. 第二层Service 在查询放回DO后**不能直接返回给前端** 必须添加**model层** 他才是真正的业务逻辑交互层

13. 在model目录编写**UserModel类** 定义所有用户字段和getter setter方法

14. 修改UserService接口中的方法返回值为UserModel类型 修改UserServiceImpl方法返回值为UserModel类型

15. 在UserServiceImpl中添加**组装方法convertFromDataObject()**方法把多个分散的User表字段组装成一个完整的User对象

16. 通过@Autowired引入UserPasswordDOMapper对象

17. 修改UserPasswordDOMapper.xml文件添加根据id查询的方法selectByUserId

18. 在UserPasswordDOMapper类中新建selectByUserId方法

19. 在UserController类中通过@Autowired引入UserService对象 给getUser方法添加@ResponseBody 同时调用service getUserById返回Model对象给前端

20. 启动App 在浏览器中通过localhost:8091/user/get?id=1访问 返回json格式的model对象 

21. 为了控制返回给前端对象的属性 在controller目录下创建viewobject目录 

22. 在viewobject目录下创建**UserVO类**  防止把对象私密信息传递给前端 **它的目标用户是前端程序员  本质上是对象的访问控制**

23. 修改UserController getUser方法返回类型为UserVO类型

24. 在UserController中添加convertFromModel方法将userModel对象转换成userVO对象（通过SpringBoot的**BeanUtils.copyProperties**方法）

25. **调试age为null异常情况**：在controller类中打断点调试 调试 浏览器刷新请求 再进入service层并打断点 发现age类型错误 **Integer类型错写成String类型**  BeanUtils.copyProperties不能自动类型转换 重启刷新完成

26. 总结：SpringMVC三层从上到下 controller service dao   dataobject负责数据库数据到service层的传输 service服务层组装model核心领域模型 controller层控制返回给前端展示的**VO对象**保证UI只使用**对象需要展示的字段**  各层负责自己的任务指责清晰 各层通行通过**@Autowired**引入某个对象实现通行交互

    

## 2. 定义通用返回对象-返回正确信息

1. 返回给前端有意义的信息

2. 归一化@ResponseBody数据：在项目新建response目录统一处理http返回数据

3. 在response目录中创建**CommonReturnType类**：定义返回数据类型 统一处理返回数据

4. 修改UserController getUser方法返回类型为CommonReturnType类型

   <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpi4s2orlej30eq0a83z1.jpg" alt="image-20210413122831770" style="zoom:50%;" />

## 3. 定义通用返回对象-返回错误信息

1. 定义通用错误数据类型：创建error目录 创建一个**CommonError接口 ** 定义一个枚举类型**BusinessErrorEnum** 统一出处理错误码信息
2. 创建**BusinessException类** 统一处理异常信息：程序抛出的任何异常可以被SpringBoot异常处理handler捕获处理
3. 上述两步使用了**包装器设计模式**
4. 在Controller中判断异常情况 抛出异常类型给SpringBoot异常处理器Handler



## 4. 定义通用返回对象-异常处理01

1. 在controller类中定义exceptionhandler处理未被controller层吸收的exception
2. web应用程序的controller层异常是最后一次业务处理 **异常处理钩子**
3. 在exceptionHandler方法上加**@ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.OK)** 表示当发生异常是仍然返回200 表示这个异常是服务器可以处理的异常而不是服务器内部错误不可处理的异常

## 5. 定义通用返回对象-异常处理02

1. 在exceptionHandler方法上加上**@ResponseBody**: 使前端页面可也显示后台返回的对象数据

2. 将exception强制转换成BusinessException类型 **便于获取特定信息**

3. 用Map对象封装异常对象 目的是**只封装异常对象特定信息**errorCode errorMsg而不是全部信息

4. 在exceptionHanlder中判断异常类型 增强程序健壮性

5. 在BusinessErrorEnum中定义未知错误 UNKNOWN_ERROR

6. 因为异常处理为所有controller的公共组件 所以在controller目录下新建BaseController类统一处理异常 使其变为所有controller的基类 **达到子类controller复用父类异常处理器的目的**

   <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpi4s3af4nj30mq0damye.jpg" alt="image-20210413150431166" style="zoom:25%;" />

   

   <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpi4s3psqfj30lc0bk0ts.jpg" alt="image-20210413150520721" style="zoom:25%;" />

   <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpi4s46rr1j30ku0aoab2.jpg" alt="image-20210413150551129" style="zoom:25%;" />

7. 总结：首先定义**CommonReturnType** 以processStatus returnData方式放回一个统一格式的json序列化对象给前端解析使用 **摈弃HttpStatusCode + tomcat内嵌错误页处理异常的方式** 其次定义**BusinessErrorEnum**枚举类型统一管理所有可能的错误码 最后在**BaseController基类**中定义一个通用异常处理类来处理未被controller层吸收的异常 同时使用Map封装统一的异常信息格式

## 6. Otp验证码获取







































































